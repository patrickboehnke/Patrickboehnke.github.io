---
title: "Hidden Markov Models for Microservices"
author: Patrick Boehnke
date: "January 3, 2025"
output:
  html_document:
    number_sections: true
---

# Introduction
I wanted to take a detour from our theoretical build up of microservices and instead focus on a common operational challenge: was my service working normally or not? There's a variety of techniques available to us for answering this question. We could set [SLOs](https://cloud.google.com/blog/products/devops-sre/sre-fundamentals-slis-slas-and-slos) and see if our service met them or not. We could set alerts on performance or error rate and see if it fired during the time period in question. However, these methods require manual effort to tune the alert^[there are some automated/data driven tuning mechanisms availble, but they still require a lot of manual effort] and expert knowledge of the system. 

This works great when you have a small number of services to monitor, but it doesn't scale to a situation where you have a dozen or more under your ownership. Once you have too many services to monitor individually, you need a way to use data to simplify the problem. What if we could build a model that automatically told us when a service was behaving normally or not.

# The magic of Hidden Markov Models
A Hidden Markov Model (HMM) is a statistical model where the output is dependent on a hidden, internal state. This state can change abruptly between a number of discrete options. The probability of transitioning from one state to another is only dependent upon the current state (the Markov property). The observed output at each time step is generated by the hidden state the model is in. 

For example, if we consider a microservice that has a single REST API endpoin^[don't worry we will expand to multiple endpoints in a future post] then most of the time it will return results in a relatively consistent amount of time. However, when the service is overloaded then the amount of time taken will increase significantly. If we consider the normal operation as one hidden state and the degraded operation as another hidden state then we can use a HMM to estimate when the service was in a normal or in a degraded state.

```{r echo=TRUE, message=FALSE}
library(ggplot2)
library(dplyr)
set.seed(42)

simulatedService <- tibble(duration = sample(seq(1,10), 100, replace = TRUE))
simulatedService %>% add_row(duration = sample(seq(1,100), 100, replace = TRUE))  %>% add_row(duration = sample(seq(1,10), 100, replace = TRUE)) %>% mutate(time_step = row_number()) -> simulatedService
ggplot(data = simulatedService) + aes(x=time_step, y=duration) + geom_line()
```

For the first 100 time steps, the service has a very low and consistent duration. However, that all changes at step 100 where all of a sudden the repsonse times become much slower and much more variable.